# 锁

[TOC]

## 锁的必要性

事务的任务是保证一系列更新语句的原子性, 当多个事务并发操作时很容易破坏事务的ACID特性,从而导致数据的不一致性问题,主要包括以下几方面:

- 丢失更新(lost update):
  两个事务同时修改同一数据,其中一个事务的提交结果破坏了另一个事务的提交结果,导致另一个事务的修改丢失.

- 脏读(dirty read):
  一个事务可以读到另一个事务未提交的数据,脏读违背了事务的隔离性原则.

- 不可重复读(non-repeatable read):
  同一个事务内两条相同的查询语句,查询结果不一致.

- 幻读(phantom read):
  同一个事务内两条相同的查询语句,查询结果应该相同,但是如果另一个事务同时提交了新数据,本事务再更新时,就会"惊奇地发现这些新数据", 而之前读到数据犹如鬼影一样的幻觉.

因此,为了保证数据的一致性、并发事务的正确执行, MySQL需要对多个并发事务进行有效的调度, 而锁是解决事务并发访问可能导致的数据不一致性的重要技术, 是MySQL实现多用户并发访问的基石.

## 锁的类型

多个事务读取同一数据时, 是不会有冲突的.同时写数据才会产生冲突.
锁的类型包括读锁(read lock)和写锁(write lock), 其中读锁也称为共享锁, 写锁也称为排他锁或者独占锁.

- 共享锁(shared lock, 也叫S锁)
  共享锁表示对数据进行读操作.
  因此多个事务可以同时为一个对象加共享锁.
  产生共享锁的语句:
  `select * from 表 where 条件 lock in share mode;`

- 排他锁(exclusive lock, 也叫X锁)
  排他锁表示对数据进行写操作.
  如果一个事务对对象加了排他锁,其它事务就不能再给它加任何锁了.
  上排他锁的写法:
  `select * from 表 where 条件 for update;`

注意：

1.两个事务不能锁同一个索引。

2.insert ，delete ， update在事务中都会自动默认加上排它锁。

<font color=red>
3.读锁允许其它客户机对数据同时进行读, 但不允许其他MySQL客户机对数据进行任何写;

4.写锁不允许其它MySQL客户机对数据同时进行读, 也不允许其它MySQL客户机对数据同时写.
</font>
