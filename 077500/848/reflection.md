# 数据结构

[TOC]

## 二叉链表&线索二叉树

- 在有N个结点的二叉链表中必定存在N+1个空链域

|lchild|LTag|data|RTag|rchild|
|:--:|:--:|:--:|:--:|:--:|

LTag = 0 lchild指示结点的左孩子
LTag = 1 lchild指示结点的前驱
RTag = 0 rchild指示结点的右孩子
RTag = 1 rchild指示结点的后继

以这种结点结构构成的二叉链表作为二叉树的存储结构,叫做**线索链表**,其中指向结点前驱和后继的指针,叫做**线索**. 加上线索的二叉树称之为**线索二叉树**(Theaded Binary Tree).

## 图

### 最小生成树

- 普里姆算法（Prim）
  > 以某顶点为起点,选取其权值最小的邻边

- 克鲁斯卡尔算法（Kruskal）
  > 选取图中权值最小的边, 不构成连通分量

### 最短路径

单源点最短路径指给定带权有向图G和源点V<sub>0</sub>, 求从V<sub>0</sub>到G中其余各顶点的最短路径

- 迪杰斯特拉(Dijkstra)
  > (1) S集合,的初态只包含V<sub>0</sub>, T集合的初态为网中除了V<sub>0</sub>之外的,所有顶点
  > (2)按各顶点与V<sub>0</sub>间**最短路径长度递增的次序**(1,2,3,...),逐个把T集合中的顶点加入到S集合中去
  > 使得从V<sub>0</sub>到S集合中各顶点的路径长度始终不大于从V<sub>0</sub>到T集合中各顶点的路径长度

|终点|1|2|3|
|:--:|:--:|:--:|:--:|
|V1|∞|∞|∞|
|V2|<V0,V2,100>|<V0,V3,V2,40>|
|V3|<V0,V3,30>|
|集合S|{V0,V3}|{V0,V3,V2}|

## 堆排序

- 需要一个记录大小的辅助空间, 每个待排序记录仅占一个存储空间
- 最坏情况下的时间复杂度: O(nlog<sub>2</sub>n)

## 静态链表

- 静态链表是用数组来实现链式存储结构，目的是方便在不设指针类型的高级程序设计语言中使用链式结构。
  > 优点是和动态链表一样，删除和插入元素时间复杂度低；
  > 不足是和数组一样，需要提前分配一块较大的空间。

## 二叉树&树&森林

- 树转换成二叉树
  > (1) 兄弟结点间加线
  > (2) 除长子(左孩子)外的孩子去线
  > (3) 层次调整(孩子靠左)
  
  ![树转换成二叉树](../img/树转换成二叉树.png)

- 二叉树转换成树
  > (1) 所有右孩子变成兄弟(不包括右孩子的左孩子)
  > (2) 将兄弟与左孩子的双亲连线
  > (3) 层次调整
  
  ![二叉树转换成树](../img/二叉树转换成树.png)

- 森林转换成二叉树
  如果F={T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>, ..., T<sub>m</sub>}是森林, 按以下规则转换成一棵二叉树B=(root, LB, RB)
  > (1) 若F为空, 即m = 0, 则B为空树;
  > (2) 若F非空, 即m != 0, 则B的根root即为森林中第一棵树的根ROOT(T<sub>1</sub>); B的左子树LB是从T<sub>1</sub>中根结点的子树森林F<sub>1</sub>={T<sub>11</sub>, T<sub>12</sub>, T<sub>13</sub>, ..., T<sub>1m</sub>}转换而成的二叉树; 其右子树RB是从森林F'={T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>, ..., T<sub>m</sub>}转换而成的二叉树

  - 做题方法1:
    > (1) 森林中的每棵树各自转换成二叉树
    > (2) 将所有的二叉树转换成一棵二叉树 (如下)
    > (2.1) 第一棵树不变
    > (2.2) 将第二棵树作为第一棵树的根的右孩子
    > (2.3) 将第三棵树作为第二棵树的根的右孩子, 以此类推
  - 做题方法2:
    ![森林转换成二叉树](../img/森林转换成二叉树.png)

- 二叉树转换成森林
  如果B=(root, LB, RB)是一课二叉树,按以下规则转换成森林F={T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>, ..., T<sub>m</sub>}
  > (1) 若B为空, 则F为空;
  > (2) 若B非空, 则F中第一棵树T<sub>1</sub>的根ROOT(T<sub>1</sub>)即为二叉树B的根root; T<sub>1</sub>中根结点是子树森林F<sub>1</sub>是由B的左子树LB转换而成的森林; F中除T<sub>1</sub>之外其余树组成的森林F'={T<sub>2</sub>, T<sub>3</sub>, ..., T<sub>3</sub>}是由B的右子树RB转换而成的森林

  - 做题方法:
    二叉树能否转化成森林看是否有右孩子?有:heavy_check_mark:则可以转化成森林, 没有:x:则只能转化成树
    > (1) 根与右孩子去线
    > (2) 右孩子的右孩子间去线, 以此类推
    > (2.1) 得到n棵二叉树, 将二叉树转换成树

    ![二叉树转换成森林.png](../img/二叉树转换成森林.png)

- 先序遍历森林(森林非空)
  > (1)访问森林中第一课树的根结点;
  > (2)先序遍历第一棵树根结点的子树森林;
  > (3)先序遍历除第一棵树之后剩余的树构成的森林;

- 中序遍历森林(森林非空)
  > (1)中序遍历森林第一棵树的根结点的子树森林;
  > (2)访问第一颗树的根结点;
  > (3)中序遍历除第一棵树之后剩余的树构成的森林;

## 哈希表

### 开放定址法&线性探测再散列

- H<sub>i</sub> = (H(key) + d<sub>i</sub>) MOD m, 其中i = 1, 2, 3, ..., k(k <= m-1)
  > H(key)为哈希函数; m为哈希表表长; d<sub>i</sub>为增量序列;
  > 增量序列的取法:
  > (1)线性探测再散列: d<sub>i</sub>= 1, 2, 3, ..., m-1;
  > (2)二次探测再散列: d<sub>i</sub>= 1<sup>2</sup>, -1<sup>2</sup>, 2<sup>2</sup>, -2<sup>2</sup>, ..., ±k<sup>2</sup>(k <= m/2)
  > (3)伪随机探测再散列: d<sub>i</sub>=伪随机数序列

## 邻接表

|adjvex|nextarc|info|
|:--:|:--:|:--:|

- 邻接点域(adjvex): 指示与顶点V<sub>i</sub>邻接的点在图中的位置
- 链域(nextarc): 指示下一条边或弧的结点
- 数据域(data): 存储和边或弧相关的信息,如权值等

若无向图中有n个顶点, e条边, 则它的邻接表需要n个头结点和2e个表结点
