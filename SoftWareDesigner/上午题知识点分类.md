# 上午题知识点分类

[TOC]

- 软件测试
  - 黑盒测试(功能测试)
  > 不考虑软件的内部结构和特性,测试软件的外部特性
  > 测试技术: 等价类划分、边界值分析、错误推测、因果图
  - 白盒测试(结构测试)
  > 根据程序的内部结构和逻辑来设计测试用例,对程序的路径和过程进行测试
  > 测试技术: 逻辑覆盖、循环覆盖、基本路径测试
  > 从弱到强: 语句\-\>判定\-\>条件\-\>判定/条件\-\>条件组合\-\>路径

- 面向对象分析
  > ①认定对象
  > ②组织对象
  > ③描述对象间的相互作用
  > ④确定对象的操作
  > ⑥定义对象的内部信息

- 动态绑定
  > 绑定就是一个把过程调用和响应调用所需要的代码加以结合的过程,在一般的程序设计语言中,绑定是在编译时进行的,叫做静态绑定.动态绑定是在运行时进行的,因此,一个给定的过程调用和代码结合直到调用发生时才进行.

- 面向对象设计的原则
  > 单一职责原则: 一个类只做一种类型的责任
  > 开闭原则: 对拓展开放, 对修改关闭
  > 里氏替换原则: 子类型必须能够替换掉他们的基类型
  > 依赖倒转原则: 抽象不应该依赖细节,细节应该依赖于抽象
  > 接口分离原则: 不应该强迫客户依赖于它们不用的方法
  > ......
  > 重用发布等价原则: 重用的粒度就是发布的粒度
  > 共同封闭原则: 包中的所有类对于同一类性质的变化应该是共同封闭的
  > 共同重用原则: 一个包中的所有类应该是共同重用的
  > 无环依赖原则: 包的依赖关系图中不允许存在环
  > 稳定依赖原则: 朝着稳定的方向进行依赖
  > 稳定抽象原则: 包的抽象程度应该和其稳定程度一致

- Python
  解释型、脚本语言
  > [in] array[1, 2] * 2
  > [out] 1 2 1 2
  > seq(1:10, 2) # 左闭右开,右边不取

  |结构|可变|有序|重复|
  |:--:|:--:|:--:|:--:|
  |元组|:x:|:heavy_check_mark:|:heavy_check_mark:|
  |字典|:heavy_check_mark:|:x:|:x:|
  |列表|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|
  |集合|:heavy_check_mark:|:x:|:x:|

- 关系代数\-关系运算
  ![22年上半年上午2425题](img/22年上半年上午2425题.png)
  > R X S 表示笛卡尔积(全连接)
  > R自然连接S(去除重复列)
  > σ表示选择
  > ∧表示与(并且/合取)
  > ∨表示或(或者/析取)
  
- 哈希表
  哈希冲突是不可避免的,只能尽量避免
  > 线性探查法: 容易产生聚集现象,降低了查找效率
  > 链地址法: 每一个记录中增加一个链域, 链域中存放相同哈希值的记录,平均查找长度和线性表相同为1

  > 装填因子: α = 表中装入的记录数 / 哈希表的长度
  > 装填因子越小发生冲突的可能性就越小, α越大表中已填入的记录就越多

- 树
  树的性质:
  1. 一个结点的子树个数记为该结点的度
  2. 树的结点个数 = 树中所有结点的度数之和再加 1
  3. 叶子结点也称终端结点,指肚为0的结点
  - 二叉树
    > 二叉树第i层(i>=1)上最多有2<sup>i-1</sup>个结点
    > 高度为k的二叉树最多有2<sup>k</sup>-1个结点(k>=1)
    ![3种二叉树](img/3种二叉树.png)
    > 满二叉树: 深度为k, 有2<sup>k</sup>-1个结点
    > 完全二叉树: 除了最后一层其余各层都是满的,且最后一层的结点从左往右放置,不能留空
  - 最小二叉树(图的最短路径): 权值最小的生成树
    连通网N = (V, E)
    - 普里姆Prim算法:
    > 以一个顶点集合U={u<sub>0</sub>}作为初态,不断寻找与U中顶点相邻且代价最小的边的另一个顶点,直到U集合中U=V为止
    - 克鲁斯卡尔Kruskal算法:
    > 在E中选择最小的边,若该边依附的顶点落在T中不同的连通分量上,则将此边加入到T中,否则舍弃此边而选择下一条代价最小的边,直到T中所有顶点都在同一连通分量上为止
  - 最优二叉树(哈夫曼树)
    > 带权路径长度最短的树，权值较大的结点离根较近, 值越大的数放在越靠下的层
  - 平衡二叉树(AVL)
    > ①任意节点的子树的高度差都小于等于1
    > ②左子树和右子树都是平衡二叉树
    > 平衡因子: 右子树深度减去左子树深度(-1,0,1)
  - B树(Balance)
    > 多路的平衡搜索树,B树的每个节点可以存储多个数据
    > 每个结点不止有2个结点,最多有上千个结点
    > 树中每个结点最多有m颗子树
    > 若根结点不是叶子结点,则最少有2颗子树
    > 除根之外的所有非叶子结点最少有m/2颗子树(向上取整)
  - B+树
    > 叶子结点保存了完整的索引和数据;
    > 非叶子结点只保存索引值,不存储数据

- 排序算法

  |排序算法|稳定性|时间复杂度|空间复杂度|
  |:-:|:-:|:-:|:-:|
  |直接插入排序|:heavy_check_mark:|n<sup>2</sup>|1|
  |冒泡排序|:heavy_check_mark:|n<sup>2</sup>|1|
  |简单选择排序|:x:|n<sup>2</sup>|1|
  |希尔排序|:x:|n<sup>1.3</sup>|1|
  |快速排序|:x:|nlog<sub>2</sub>n ~ n<sup>2</sup>|1|
  |堆排序|:x:|nlog<sub>2</sub>n|1|
  |归并排序|:heavy_check_mark:|nlog<sub>2</sub>n|n|

  
