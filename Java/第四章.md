# 面向对象(下)

[TOC]

## 类的继承

### 继承的概念

在程序中，继承指的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关联体系；
在Java中，类的继承指在一个现有类的基础上构建一个新的类，构建出来的新类被称作子类，现有类被称作父类或基类，`子类会自动拥有父类所有可继承的属性和方法`

`在程序中,如果想要声明一个类继承另一个类需要使用extends关键字`

> [修饰符] class 类名 extends 父类名 {
> // 程序核心代码
> }

```java
class Animal{ // Dog类的父类

    String name;

    void shout () {

        System.out.println("吼叫声!!!");
    }
}

class Dog extends Animal { //继承自Animal类的Dog类

    public void printName() {

        System.out.println("name=" +name);
    }
}

public class Example01 {

    public static void main(String[] args) {

        Dog dog = new Dog(); //创建一个Dog类的实例对象

        dog.name = "沙皮狗"; //为dog对象的name属性赋值

        dog.printName(); //调用dog对象的printName方法

        dog.shout(); //调用Dog类继承来的shout方法
    }
}
```

1. Java中,类只支持单继承,不允许多重继承,一个类只能有一个父类
2. 多个类可以继承一个父类
3. Java中,多层继承是可以的,即一个类的父类可以再去继承另外的父类
4. 父类与子类是一种相对的概念

### 重写父类方法

子类会继承父类中公共的方法,但有时需要在子类中对父类方法进行修改,即对父类方法进行重写

子类中重写方法父类被重写的方法具有**相同**的`方法名`,`参数列表`以及`返回值类型`

<u>子类重写父类方法时,不能使用比父类中被重写的方法更严格的访问权限</u>,如果父类方法的访问权限是public,子类重写这个方法不能使用private

```java
class Animal {

    void shout() {

        System.out.println("动物发出叫声!");
    }
}

class Dog extends Animal {

    void shout() { //重写父类的shout方法

        System.out.println("汪汪汪!");
    }
}

public class Example02 {

    public static void main(String[] args){

        Dog dog = new Dog(); //创建Dog类的实例对象

        dog.shout(); //调用重写的shout方法
    }
}
```

### super关键字

在Java中专门提供了一个super关键字来访问父类的成员,例如访问父类的成员变量,成员方法和构造方法

1.使用super关键字调用父类的成员变量和成员方法
> super.成员变量
> super.成员方法([参数1, 参数2, ...])

```java
class Animal {

    String name = "动物";

    void shout() {

        System.out.println("动物发出叫声!");
    }
}

class Dog extends Animal { //Animal的子类--Dog类

    String name = "犬类";

    void shout() { //重写继承自父类的shout方法

        super.shout(); //访问父类的shout方法
    }

    void printName() {

        System.out.println("name=" +super.name); //访问父类的成员变量
    }
}

public class Example03 {

    public static void main(String[] args){

        Dog dog = new Dog(); //创建一个dog对象

        dog.shout(); //调用dog对象重写的shout方法

        dog.printName(); //调用dog对象的printName方法
    }
}
```

2.使用super关键字调用父类的构造方法
> super([参数1, 参数2, ...])

```java
class Animal {

    public Animal(String name){ //Animal类的有参构造方法

        System.out.println("我是" +name);
    }

    public Animal() { //一旦定义了构造方法,系统不再提供默认的无参构造方法

        System.out.println("Animal的无参构造方法");
    }
}

class Dog extends Animal { //Dog类继承自Animal类

    public Dog(){ //Dog类的无参构造方法

        super("傻狗"); //访问父类的构造方法,并传入String参数"傻狗"
    }
}

public class Example04 {

    public static void main(String[] args){

        Dog dog = new Dog(); //创建Dog类的实例对象
        //输出为"我是傻狗"
    }
}
```

`通过super调用父类构造方法的代码必须位于子类构造方法的第一行,并且只能出现一次`
另外,如果注释掉上述代码的第11行,即super("傻狗")这一句:程序编译出现错误,显示"Implicit super constructor Animal() is undefined. Must explicitly invoke another constructor(未定义隐式无参构造方法,必须显示地调用另一个构造方法)"
原因在于,`在子类的构造方法中一定会调用父类的某个构造方法`,可以在子类中`通过super关键字指定调用父类的哪个构造方法`,如果没有指定,`在实例化子类对象时,默认调用父类的无参构造方法`

```java
class Animal {

    public Animal(){ //Animal的无参构造方法

        System.out.println("我是一只动物!");
    }

    public Animal(String name){ //Animal的有参构造方法

        System.out.println("我是一只" +name);
    }
}

class Dog extends Animal { //Animal的子类

    public Dog(){ //Dog无参构造方法

    }

    public Dog(String name){ //Dog的有参构造方法

        System.out.println("我是一只" +name);
    }
}

public class Example05 {

    public static void main(String[] args){

        Dog dog = new Dog(); //通过Dog的无参构造方法(父类的无参构造方法)实例化对象
    }
}
```

:warning:如果没有特殊需求,当定义了有参构造方法后,尽量在类中再显示定义一个无参构造方法

### Object类



## final关键字

## 抽象类和接口

## 多态

## 内部类

## JDK 8 的Lambda表达式

## 异常

## 垃圾回收机制
