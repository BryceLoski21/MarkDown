# 线程安全问题的引出

JDK1.5之后提供了一个StringBuilder类,功能与StringBuffer类似.
StringBuilder(异步)没有实现线程安全功能,所以性能略高.StringBuffer(同步)是线程安全的.
同步: 按顺序执行,一步一步来(synchronic)
异步: 接一个任务,直接给后台,**在**接下一个,谁先读取完谁先执行,没有顺序,可能导致上面代码还没出来,下面代码就出来了.
创建一个内容可变的字符串对象时,优先考虑StringBuffer类.

## 什么是线程安全与不安全

假设A和B同时去不同ATM上取同一张卡的1000块钱，如果是线程不安全，那么A和B可以同时取到1000块钱（两人赚大发啦），而如果线程安全呢，就只有一个人能取出来1000块钱。

线程安全是指多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的，不存在执行结果的二义性。

线程不安全就是不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据.

## 决定线程安全的因素

线程安全问题都是由全局变量及静态变量引起的。

若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

## 解决办法

1. 同步代码块

    ```java
    synchronized(同步锁){
        //方法体
    }
    ```

2. 同步方法: 给多线程访问的成员方法加上synchronized修饰符

    ```java
    public synchronized void test() {
        //方法体
    }
    ```

    synchronized,当它修饰一个方法或者一个代码块时,能够保证在同一时刻最多只有一个线程执行该段代码.

3. 锁机制(Lock)

   ```java
    //Java提供的同步代码块的另一种机制，比synchronized关键字更强大也更加灵活。
    //这种机制基于Lock接口及其实现类（例如：ReentrantLock）
    //它比synchronized关键字好的地方：
    //1、提供了更多的功能。tryLock()方法的实现，这个方法试图获取锁，
    //如果锁已经被其他线程占用，它将返回false并继续往下执行代码。
    //2、Lock接口允许分离读和写操作，允许多个线程读和只有一个写线程。
    //3、具有更好的性能
    public class PrintQueue {
      private final Lock A=new ReentrantLock();
    //...
    }
   ```
