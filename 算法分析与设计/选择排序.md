# 选择排序

[TOC]

## 算法描述

选择排序就是从无序的数组中, 每次<b>选择最小或最大</b>的数据, 从无序数组中<b>放到有序数组的末尾</b>, 最终得到一个有序的数组.

- 时间复杂度
  > 最好情况O(n<sup>2</sup>)
  > 最坏情况O(n<sup>2</sup>)
  > 平均时间复杂度O(n<sup>2</sup>)

- 空间复杂度O(1)

- 选择排序是一个不稳定的排序算法

## 代码实现

Python实现:

```python
nums = [5, 3, 6, 4, 1, 2, 8, 7]
res = [] # 用于存储已排序的数组
while len(nums): # 当未排序数组内还有元素时, 重复执行选择最小的元素
    minIndex = 0 # 初始化最小数下标的变量, 默认为第一个数
    for i in range(1, len(nums)): 
        if(num[i] < nums[minIndex]): # 更新最小数的下标
            minIndex = i
    temp = nums[minIndex]
    nums.pop(minIndex) # 把最小数从未排列数组中删除
    res.append(temp) # 把最小数插入到已排序数组的末尾
print(res)
```

C++实现:

```C++
void selecture_sort(int a[], int n){
    for(int i = 0; i < n - 1; i++){
        int min_i = i; //min_i表示最小数的下标
        for(int j = i + 1; j < n; j++){
            if(a[j] < a[min_i])
                min_i = j;
            swap(a[j], a[min_i]); //a[j]与a[min_i]交换位置
        }
    }
}
```
