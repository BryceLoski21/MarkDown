# 冒泡排序

[TOC]

# 算法描述

冒泡排序采用重复遍历数组并依次比较相邻元素的方法来排序, 在排序过程中, 最大数/最小数会慢慢"浮"到数组的末尾.

- 时间复杂度
  > 最好情况O(n)
  > 最坏情况O(n<sup>2</sup>)
  > 平均时间复杂度O(n<sup>2</sup>)

- 空间复杂度O(1)

- 冒泡排序是一个稳定的排序算法

<font color=red>注: 当数组中有两个元素相等时, 为保留它们的原有相对位置, 不要进行交换, 如果把运算符写成大于等于号, 排序算法的稳定性就被破坏了.</font> 

## 代码实现

Python实现:

```python
nums = [5, 3, 6, 4, 1, 2, 8, 7]
for i in range(len(nums), 0, -1): # 更新本次遍历确定的元素位置
    flag = 0 # 标记是否有元素发生交换
    for j in range(i - 1): # 遍历未排序的数组
        if nums[j] > nums[j + 1]:
            nums[j], nums[j + 1] = nums[j + 1], nums[j]
            flag = 1 # 标记存在元素交换
    if not flag:
        break # 如果没有发生元素互换, 跳出循环
print(nums)
```

C++实现:

```C++
void bubble_sort(int a[], int n){
    for (int i = 0; i < n - 1; i++){ //i控制排序的轮数 
        for (int j = 0; j < n - i - 1; j++){ //j控制每轮需要比较的次数
            if(a[j + 1] < a[j]){
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}
```

<!-- 你是什么样的人, 你就会遇到什么样的人, 偶尔也会遇到和你不一样的人, 但你要坚守本心, 你不能变得和他们一样! -->
